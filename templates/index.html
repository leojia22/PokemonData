<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pok√©mon Tournament Data Explorer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            background-color: #f8f9fa;
            padding-top: 20px;
        }
        .deck-card {
            transition: transform 0.2s;
            margin-bottom: 20px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .deck-card:hover {
            transform: translateY(-5px);
        }
        .deck-header {
            background-color: #2c3e50;
            color: white;
            padding: 10px 15px;
            font-weight: bold;
        }
        .stat-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        .stat-label {
            color: #7f8c8d;
            font-size: 14px;
        }
        
        /* D3.js Chart Styles */
        #deck-chart {
            width: 100%;
            height: 400px;
            margin: 0 auto;
        }
        
        .arc text {
            font: 12px sans-serif;
            text-anchor: middle;
            pointer-events: none;
        }
        
        .arc path {
            stroke: #fff;
        }
        
        .tooltip-deck {
            position: absolute;
            padding: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            max-width: 200px;
            z-index: 1000;
        }
        .table th {
            background-color: #2c3e50;
            color: white;
        }
        .filter-section {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="row mb-4">
            <div class="col-12 text-center">
                <h1 class="display-4">Toronto Regionals Tournament Explorer</h1>
            </div>
        </div>

        <!-- Filters -->
        <div class="filter-section">
            <h5><i class="bi bi-funnel"></i> Filters</h5>
            <div class="row">
                <div class="col-md-3">
                    <label class="form-label">Deck</label>
                    <select class="form-select" id="deck-filter">
                        <option value="All">All Decks</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <label class="form-label">Country</label>
                    <select class="form-select" id="country-filter">
                        <option value="All">All Countries</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <label class="form-label">Min Placement</label>
                    <input type="number" class="form-control" id="min-placement" placeholder="Min">
                </div>
                <div class="col-md-3">
                    <label class="form-label">Max Placement</label>
                    <input type="number" class="form-control" id="max-placement" placeholder="Max">
                </div>
            </div>
        </div>

        <!-- Tabs Navigation -->
        <ul class="nav nav-tabs mb-4" id="mainTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="results-tab" data-bs-toggle="tab" data-bs-target="#results" type="button" role="tab" aria-controls="results" aria-selected="true">
                    <i class="bi bi-table"></i> Tournament Results
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="decks-tab" data-bs-toggle="tab" data-bs-target="#decks" type="button" role="tab" aria-controls="decks" aria-selected="false">
                    <i class="bi bi-pie-chart"></i> Deck Distribution
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="winrate-tab" data-bs-toggle="tab" data-bs-target="#winrate" type="button" role="tab" aria-controls="winrate" aria-selected="false">
                    <i class="bi bi-graph-up"></i> Win Rate Analysis
                </button>
            </li>
        </ul>

        <!-- Tab Content -->
        <div class="tab-content" id="mainTabsContent">
            <!-- Results Tab -->
            <div class="tab-pane fade show active" id="results" role="tabpanel" aria-labelledby="results-tab">
                <!-- Data Table -->
                <div class="card mb-4">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0"><i class="bi bi-table"></i> Tournament Results</h5>
                <span class="badge bg-primary" id="result-count">0 results</span>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Name</th>
                                <th>Country</th>
                                <th>Deck</th>
                                <th>Points</th>
                                <th>Record</th>
                                <th>Wins</th>
                                <th>Losses</th>
                                <th>Placement</th>
                            </tr>
                        </thead>
                        <tbody id="data-table">
                            <!-- Data will be loaded here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

            </div>

            <!-- Decks Tab -->
            <div class="tab-pane fade" id="decks" role="tabpanel" aria-labelledby="decks-tab">
                <div class="row">
                    <!-- Pie Chart -->
                    <div class="col-md-6 mb-4">
                        <div class="card h-100">
                            <div class="card-header">
                                <h5 class="mb-0"><i class="bi bi-pie-chart"></i> Deck Distribution</h5>
                            </div>
                            <div class="card-body">
                                <div id="deck-chart"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Deck Statistics Table -->
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header">
                                <h5 class="mb-0"><i class="bi bi-table"></i> Deck Performance</h5>
                            </div>
                            <div class="card-body">
                                <div class="table-responsive">
                                    <table class="table table-striped" id="deck-stats-table">
                                        <thead>
                                            <tr>
                                                <th>Deck</th>
                                                <th>Players</th>
                                                <th>Avg. Placement</th>
                                                <th>Win Rate</th>
                                            </tr>
                                        </thead>
                                        <tbody id="deck-stats-body">
                                            <!-- Deck stats will be loaded here -->
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Win Rate Analysis Tab -->
            <div class="tab-pane fade" id="winrate" role="tabpanel" aria-labelledby="winrate-tab">
                <div class="card mb-4">
                    <div class="card-header">
                        <h5 class="mb-0"><i class="bi bi-graph-up"></i> Win Rate vs. Popularity</h5>
                    </div>
                    <div class="card-body">
                        <div id="winrate-chart"></div>
                        <div class="mt-3">
                            <p class="text-muted small mb-0">
                                <i class="bi bi-info-circle"></i> Each bubble represents a deck. Size indicates total matches played.
                                Color indicates average placement (green = better). Hover for details.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Global variables
        let allData = [];
        let currentFilters = {
            deck: 'All',
            country: 'All',
            minPlacement: '',
            maxPlacement: ''
        };

        // DOM Elements
        const deckFilter = document.getElementById('deck-filter');
        const countryFilter = document.getElementById('country-filter');
        const minPlacement = document.getElementById('min-placement');
        const maxPlacement = document.getElementById('max-placement');
        const dataTable = document.getElementById('data-table');
        const resultCount = document.getElementById('result-count');
        const deckStatsBody = document.getElementById('deck-stats-body');

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            loadData();
            loadDeckStats();
            
            // Handle tab changes
            document.querySelectorAll('#mainTabs button[data-bs-toggle="tab"]').forEach(tab => {
                tab.addEventListener('shown.bs.tab', function (event) {
                    const filterSection = document.querySelector('.filter-section');
                    
                    // Show/hide filters based on active tab
                    if (event.target.id === 'results-tab') {
                        filterSection.style.display = 'block';
                    } else if (event.target.id === 'decks-tab') {
                        filterSection.style.display = 'none';
                        loadDeckStats();
                    } else if (event.target.id === 'winrate-tab') {
                        filterSection.style.display = 'none';
                        loadWinrateStats();
                    }
                });
            });

                // Add event listeners
            deckFilter.addEventListener('change', (e) => {
                currentFilters.deck = e.target.value;
                updateData();
            });
            
            countryFilter.addEventListener('change', (e) => {
                currentFilters.country = e.target.value;
                updateData();
            });
            
            minPlacement.addEventListener('change', (e) => {
                currentFilters.minPlacement = e.target.value;
                updateData();
            });
            
            maxPlacement.addEventListener('change', (e) => {
                currentFilters.maxPlacement = e.target.value;
                updateData();
            });
        }); // Close DOMContentLoaded

        // Load tournament data
        async function loadData() {
            try {
                const response = await fetch('/api/data');
                const data = await response.json();
                allData = data.data;
                
                // Update filters and render table
                updateFilterOptions(data.filters);
                
                // Render table
                renderTable(allData);
            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        // Load deck statistics
        async function loadDeckStats() {
            try {
                console.log('Loading deck stats...');
                const response = await fetch('/api/decks');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const deckStats = await response.json();
                console.log('Deck stats loaded:', deckStats);
                if (deckStats && deckStats.length > 0) {
                    renderDeckStats(deckStats);
                } else {
                    console.warn('No deck statistics data received');
                    document.getElementById('deck-chart').innerHTML = '<p class="text-center text-muted">No deck statistics available</p>';
                }
            } catch (error) {
                console.error('Error loading deck stats:', error);
                document.getElementById('deck-chart').innerHTML = `
                    <div class="alert alert-danger">
                        <strong>Error loading deck statistics:</strong> ${error.message}
                    </div>
                `;
            }
        }

        // Update data based on filters
        async function updateData() {
            try {
                const params = new URLSearchParams();
                if (currentFilters.deck !== 'All') params.append('deck', currentFilters.deck);
                if (currentFilters.country !== 'All') params.append('country', currentFilters.country);
                if (currentFilters.minPlacement) params.append('min_placement', currentFilters.minPlacement);
                if (currentFilters.maxPlacement) params.append('max_placement', currentFilters.maxPlacement);
                
                const response = await fetch(`/api/data?${params.toString()}`);
                const data = await response.json();
                
                // Render table with filtered data
                renderTable(data.data);
            } catch (error) {
                console.error('Error updating data:', error);
            }
        }

        // Update filter dropdowns
        function updateFilterOptions(filters) {
            // Update deck filter
            deckFilter.innerHTML = '<option value="All">All Decks</option>';
            filters.decks.forEach(deck => {
                if (deck !== 'All') {
                    const option = document.createElement('option');
                    option.value = deck;
                    option.textContent = deck;
                    deckFilter.appendChild(option);
                }
            });
            
            // Update country filter
            countryFilter.innerHTML = '<option value="All">All Countries</option>';
            filters.countries.forEach(country => {
                if (country !== 'All') {
                    const option = document.createElement('option');
                    option.value = country;
                    option.textContent = country;
                    countryFilter.appendChild(option);
                }
            });
            
            // Update placement range
            if (!minPlacement.value) minPlacement.placeholder = filters.min_placement;
            if (!maxPlacement.value) maxPlacement.placeholder = filters.max_placement;
        }

        // Render data table
        function renderTable(data) {
            dataTable.innerHTML = '';
            
            if (data.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="9" class="text-center">No data found matching your filters</td>';
                dataTable.appendChild(row);
                resultCount.textContent = '0 results';
                return;
            }
            
            data.forEach(player => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${player.Placement}</td>
                    <td><strong>${player.Name}</strong></td>
                    <td>${player.Country}</td>
                    <td><span class="badge bg-primary">${player.Deck}</span></td>
                    <td>${player.Points}</td>
                    <td>${player.Record}</td>
                    <td>${player.Wins}</td>
                    <td>${player.Losses}</td>
                    <td><span class="badge ${player.Placement <= 8 ? 'bg-success' : 'bg-secondary'}">${player.Placement}</span></td>
                `;
                dataTable.appendChild(row);
            });
            
            resultCount.textContent = `${data.length} result${data.length !== 1 ? 's' : ''}`;
        }

        // Render deck statistics and pie chart
        function renderDeckStats(deckStats) {
            // Update the table
            const deckStatsBody = document.getElementById('deck-stats-body');
            deckStatsBody.innerHTML = '';
            
            // Process data for the pie chart
            const pieData = deckStats.map(deck => ({
                name: deck.Deck,
                value: deck.count,
                avg_placement: deck.avg_placement.toFixed(1),
                win_rate: ((deck.avg_wins / (deck.avg_wins + deck.avg_losses)) * 100).toFixed(1)
            }));
            
            // Sort by count (descending)
            pieData.sort((a, b) => b.value - a.value);
            
            // Update the table with the sorted data
            pieData.forEach(deck => {
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td><strong>${deck.name}</strong></td>
                    <td>${deck.value}</td>
                    <td>${deck.avg_placement}</td>
                    <td>
                        <div class="progress">
                            <div class="progress-bar bg-success" role="progressbar" 
                                 style="width: ${deck.win_rate}%" 
                                 aria-valuenow="${deck.win_rate}" 
                                 aria-valuemin="0" 
                                 aria-valuemax="100">
                                ${deck.win_rate}%
                            </div>
                        </div>
                    </td>
                `;
                deckStatsBody.appendChild(row);
            });
            
            // Create the pie chart
            createPieChart(pieData);
        }
        
        // Create D3.js pie chart
        function createPieChart(data) {
            console.log('Creating pie chart with data:', data);
            
            // Clear previous chart and show loading state
            const container = d3.select("#deck-chart");
            container.html('<div class="text-center"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div></div>');
            
            try {
                // Filter out any invalid data
                const validData = data.filter(d => d && d.name && d.value > 0);
                
                if (validData.length === 0) {
                    container.html('<p class="text-center text-muted">No valid deck data available for visualization</p>');
                    return;
                }
                
                // Clear previous chart
                container.html("");
                
                // Set up dimensions
                const width = container.node().clientWidth;
                const height = 400;
                const radius = Math.min(width, height) / 2 - 40;
                
                // Create tooltip
                const tooltip = d3.select("body")
                    .append("div")
                    .attr("class", "tooltip-deck")
                    .style("opacity", 0);
                
                // Create color scale
                const color = d3.scaleOrdinal()
                    .domain(validData.map(d => d.name))
                    .range(validData.map((d, i) => d.color || d3.schemeCategory10[i % 10]));
                
                // Create SVG
                const svg = container
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .append("g")
                    .attr("transform", `translate(${width / 2}, ${height / 2})`);
                
                // Create pie layout
                const pie = d3.pie()
                    .sort(null)
                    .value(d => d.value);
                
                // Create arc generator
                const arc = d3.arc()
                    .innerRadius(0)
                    .outerRadius(radius);
                
                // Create arcs
                const arcs = svg.selectAll(".arc")
                    .data(pie(validData))
                    .enter()
                    .append("g")
                    .attr("class", "arc");
                
                // Draw arcs with animation
                arcs.append("path")
                    .attr("d", arc)
                    .attr("fill", d => color(d.data.name))
                    .style("opacity", 0)
                    .transition()
                    .duration(1000)
                    .style("opacity", 1)
                    .attrTween("d", function(d) {
                        const i = d3.interpolate(d.startAngle + 0.1, d.endAngle);
                        return function(t) {
                            d.endAngle = i(t);
                            return arc(d);
                        };
                    });
                
                // Add hover effects
                arcs.selectAll("path")
                    .on("mouseover", function(event, d) {
                        d3.select(this).transition()
                            .duration(200)
                            .attr("opacity", 0.8);
                        
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        
                        tooltip.html(`
                            <strong>${d.data.name}</strong><br>
                            Players: ${d.data.value}<br>
                            ${d.data.avg_placement ? `Avg. Placement: ${d.data.avg_placement}<br>` : ''}
                            ${d.data.win_rate ? `Win Rate: ${d.data.win_rate}%` : ''}
                        `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this).transition()
                            .duration(200)
                            .attr("opacity", 1);
                        
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
                
                // Add labels to larger slices
                arcs.append("text")
                    .attr("transform", d => `translate(${arc.centroid(d)})`)
                    .attr("dy", ".35em")
                    .style("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .style("fill", "#fff")
                    .style("text-shadow", "1px 1px 2px rgba(0,0,0,0.7)")
                    .style("pointer-events", "none")
                    .text(d => d.data.value > 5 ? d.data.value : "");
                
                // Add legend for top decks
                const legendItemHeight = 20;
                const legendX = radius + 20;
                const legendY = -Math.min(validData.length * legendItemHeight / 2, 100);
                
                // Sort data by value (descending) and take top 10
                const topDecks = [...validData]
                    .sort((a, b) => b.value - a.value)
                    .slice(0, 10);
                
                const legend = svg.selectAll(".legend")
                    .data(topDecks)
                    .enter().append("g")
                    .attr("class", "legend")
                    .attr("transform", (d, i) => `translate(${legendX}, ${legendY + i * legendItemHeight})`);
                
                legend.append("rect")
                    .attr("width", 10)
                    .attr("height", 10)
                    .style("fill", d => color(d.name));
                
                legend.append("text")
                    .attr("x", 15)
                    .attr("y", 9)
                    .attr("dy", ".35em")
                    .style("font-size", "10px")
                    .style("cursor", "default")
                    .text(d => `${d.name} (${d.value})`);
                
                console.log('Pie chart created successfully');
                
            } catch (error) {
                console.error('Error creating pie chart:', error);
                container.html(`
                    <div class="alert alert-danger">
                        <strong>Error creating chart:</strong> ${error.message}
                    </div>
                `);
            }
        }
        
        // Win Rate vs Popularity Scatter Plot
        async function loadWinrateStats() {
            try {
                console.log('Loading win rate stats...');
                const response = await fetch('/api/winrate-stats');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const winrateData = await response.json();
                console.log('Win rate stats loaded:', winrateData);
                
                if (winrateData && winrateData.length > 0) {
                    createWinrateChart(winrateData);
                } else {
                    console.warn('No win rate data received');
                    document.getElementById('winrate-chart').innerHTML = '<p class="text-center text-muted">No win rate data available</p>';
                }
            } catch (error) {
                console.error('Error loading win rate stats:', error);
                document.getElementById('winrate-chart').innerHTML = `
                    <div class="alert alert-danger">
                        <strong>Error loading win rate statistics:</strong> ${error.message}
                    </div>
                `;
            }
        }
        
        function createWinrateChart(data) {
            console.log('Creating win rate chart with data:', data);
            const container = d3.select("#winrate-chart");
            container.html('<div class="text-center"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div></div>');
            
            try {
                // Filter out invalid data
                const validData = data.filter(d => d && d.player_count > 0 && d.win_rate !== null && d.win_rate !== undefined);
                
                if (validData.length === 0) {
                    container.html('<p class="text-center text-muted">No valid data available for visualization</p>');
                    return;
                }
                
                container.html("");
                
                // Set up dimensions
                const margin = {top: 20, right: 100, bottom: 60, left: 60};
                const width = container.node().clientWidth - margin.left - margin.right;
                const height = 500 - margin.top - margin.bottom;
                
                // Create SVG
                const svg = container
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);
                
                // Set up scales
                const x = d3.scaleLinear()
                    .domain([0, d3.max(validData, d => d.player_count) * 1.1])
                    .range([0, width]);
                
                const y = d3.scaleLinear()
                    .domain([0, 100])
                    .range([height, 0]);
                
                // Create size scale for bubbles
                const size = d3.scaleSqrt()
                    .domain([0, d3.max(validData, d => d.total_matches)])
                    .range([5, 30]);
                
                // Add X axis
                svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x).ticks(5).tickFormat(d => d));
                
                // Add Y axis
                svg.append("g")
                    .call(d3.axisLeft(y).ticks(5).tickFormat(d => `${d}%`));
                
                // Add X axis label
                svg.append("text")
                    .attr("text-anchor", "middle")
                    .attr("x", width / 2)
                    .attr("y", height + margin.bottom - 10)
                    .text("Number of Players");
                
                // Add Y axis label
                svg.append("text")
                    .attr("text-anchor", "middle")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -margin.left + 20)
                    .attr("x", -height / 2)
                    .text("Win Rate (%)");
                
                // Add chart title
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", -10)
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .style("font-weight", "bold")
                    .text("Deck Win Rate vs. Popularity");
                
                // Create a tooltip
                const tooltip = d3.select("body")
                    .append("div")
                    .attr("class", "tooltip-deck")
                    .style("opacity", 0);
                
                // Add dots
                svg.selectAll("dot")
                    .data(validData)
                    .enter()
                    .append("circle")
                    .attr("cx", d => x(d.player_count))
                    .attr("cy", d => y(d.win_rate))
                    .attr("r", d => size(d.total_matches))
                    .style("fill", d => d.color || "#69b3a2")
                    .style("opacity", 0.7)
                    .on("mouseover", function(event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .style("opacity", 1)
                            .style("stroke", "#000")
                            .style("stroke-width", 2);
                        
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        
                        tooltip.html(`
                            <strong>${d.Deck}</strong><br>
                            Players: ${d.player_count}<br>
                            Win Rate: ${d.win_rate.toFixed(1)}%<br>
                            Matches: ${d.total_matches}<br>
                            Avg. Placement: ${d.avg_placement?.toFixed(1) || 'N/A'}<br>
                            Best Placement: ${d.best_placement || 'N/A'}<br>
                            Worst Placement: ${d.worst_placement || 'N/A'}
                        `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .style("opacity", 0.7)
                            .style("stroke", "none");
                        
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
                
                // Add legend for bubble size
                const legend = svg.append("g")
                    .attr("class", "bubble-legend")
                    .attr("transform", `translate(${width - 100}, ${height - 100})`);
                
                const sizes = [
                    d3.min(validData, d => d.total_matches),
                    d3.mean(validData, d => d.total_matches),
                    d3.max(validData, d => d.total_matches)
                ];
                
                legend.selectAll("circle")
                    .data(sizes)
                    .enter()
                    .append("circle")
                    .attr("cx", 10)
                    .attr("cy", (d, i) => i * 25)
                    .attr("r", d => size(d))
                    .style("fill", "none")
                    .style("stroke", "#666");
                
                legend.selectAll("text")
                    .data(sizes)
                    .enter()
                    .append("text")
                    .attr("x", 30)
                    .attr("y", (d, i) => i * 25 + 5)
                    .style("font-size", "10px")
                    .text(d => `${d} matches`);
                
                // Add legend for color
                const colorLegend = svg.append("g")
                    .attr("class", "color-legend")
                    .attr("transform", `translate(${width - 100}, 20)`);
                
                colorLegend.append("text")
                    .attr("x", 0)
                    .attr("y", 0)
                    .style("font-size", "10px")
                    .style("font-weight", "bold")
                    .text("Placement:");
                
                const placements = [
                    {label: "Best", value: d3.min(validData, d => d.avg_placement)},
                    {label: "Average", value: d3.mean(validData, d => d.avg_placement)},
                    {label: "Worst", value: d3.max(validData, d => d.avg_placement)}
                ];
                
                colorLegend.selectAll(".color-legend-item")
                    .data(placements)
                    .enter()
                    .append("g")
                    .attr("class", "color-legend-item")
                    .attr("transform", (d, i) => `translate(0, ${(i + 1) * 20})`)
                    .each(function(d) {
                        const g = d3.select(this);
                        g.append("rect")
                            .attr("width", 15)
                            .attr("height", 15)
                            .style("fill", getColorForPlacement(d.value, validData));
                        
                        g.append("text")
                            .attr("x", 20)
                            .attr("y", 12)
                            .style("font-size", "10px")
                            .text(`${d.label} (${d.value.toFixed(1)})`);
                    });
                
                console.log('Win rate chart created successfully');
                
                function getColorForPlacement(placement, data) {
                    const maxPlacement = d3.max(data, d => d.avg_placement);
                    const minPlacement = d3.min(data, d => d.avg_placement);
                    const range = maxPlacement - minPlacement || 1;
                    const normalized = (maxPlacement - placement) / range;
                    
                    const r = Math.floor(255 * (1 - normalized));
                    const g = Math.floor(255 * normalized);
                    return `rgb(${r},${g},0)`;
                }
            } catch (error) {
                console.error('Error creating win rate chart:', error);
                container.html(`
                    <div class="alert alert-danger">
                        <strong>Error creating win rate chart:</strong> ${error.message}
                    </div>
                `);
            }
        }
        
        // Handle window resize
        let resizeTimer;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(function() {
                if (document.getElementById('decks-tab').classList.contains('active')) {
                    loadDeckStats(); // Reload deck stats to redraw chart
                } else if (document.getElementById('winrate-tab').classList.contains('active')) {
                    loadWinrateStats(); // Reload win rate stats to redraw chart
                }
            }, 250);
        });
    </script>
</body>
</html>